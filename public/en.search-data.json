{"/barakah-tech-journey/about/":{"data":{"1-positively-impact-your-community#1. Positively Impact Your Community":"Our work should serve something greater than ourselves. Whether we‚Äôre building software, teaching, or serving in any capacity, we should ask: How does this benefit the people around me? How does this strengthen my community?\nTechnology has immense power to uplift communities, but only when we intentionally direct it toward that purpose.","2-never-compromise-your-values#2. Never Compromise Your Values":"The pressure to compromise is real. The job market will tempt you to work on projects that contradict your principles, to accept cultures that erode your character, or to chase opportunities that enrich your bank account while impoverishing your soul.\nSeeking barakah means drawing clear lines and having the courage to say no‚Äîeven when it‚Äôs difficult, even when others don‚Äôt understand.","3-strive-for-excellence-ihsan#3. Strive for Excellence (Ihsan)":"Ihsan (ÿ•ÿ≠ÿ≥ÿßŸÜ) means excellence, perfection, and doing beautiful work‚Äîas if you‚Äôre being watched by the Divine. It‚Äôs the principle of giving your absolute best in everything you do, not for recognition or reward, but because excellence itself is an act of worship.\nIn tech, this means writing clean code, thinking deeply about user experience, mentoring others generously, and approaching every task with integrity and craftsmanship.","about-barakah-tech-journey#About Barakah Tech Journey":"About Barakah Tech Journey","join-the-journey#Join the Journey":"If you‚Äôre also trying to find barakah in your work‚Äîwhether in tech or any other field‚ÄîI hope these reflections resonate with you. Let‚Äôs build careers that don‚Äôt just advance our own interests, but elevate our communities and honor our values.\nMay our work be filled with barakah, and may we find success in both this life and the next.","my-choice-purpose-over-prestige#My Choice: Purpose Over Prestige":"Currently, I‚Äôm a Computer Science senior at NC State University with a 3.71 GPA, and I work as a Full-Stack Software Engineer at Axiom Software‚Äîa startup you‚Äôve probably never heard of. When I had the opportunity to join Axiom, I made a deliberate choice that went against conventional wisdom in tech recruiting.\nI chose to work for a startup that has a clear vision: to help build and invest in the Muslim community. While others were chasing FAANG offers and unicorn startups, I found something more valuable‚Äîa company that aligns with my values and contributes to the growth and empowerment of my community.\nAt Axiom, I‚Äôm not just building features; I‚Äôm creating tools that help organizations serve our community better. Whether it‚Äôs developing CRM integrations, building email campaign systems, or implementing prospect management dashboards, every line of code serves a higher purpose.","the-crisis-of-purpose-in-tech#The Crisis of Purpose in Tech":"Today‚Äôs job market has left many young professionals in tech feeling desperate‚Äîwilling to work anywhere, for anyone, doing anything, just to get that first role or next opportunity. I‚Äôve felt this pressure myself. The tech industry‚Äôs materialistic culture constantly pushes us to chase higher salaries, prestigious titles, and impressive company names, often at the expense of our core values and principles.\nWe‚Äôre told to optimize our resumes, game the interview process, and maximize our compensation packages. But somewhere in this race, many of us lose sight of a fundamental question: What are we actually building, and who are we building it for?","three-pillars-of-barakah-in-work#Three Pillars of Barakah in Work":"Through my journey, I‚Äôve learned that seeking barakah in our careers requires commitment to three fundamental principles:","what-is-barakah#What is Barakah?":"Barakah (ÿ®ÿ±ŸÉÿ©) is an Arabic word that translates to ‚Äúblessing‚Äù or ‚Äúdivine abundance.‚Äù But it‚Äôs so much more than material prosperity. Barakah represents a spiritual richness that permeates our work, relationships, and daily lives. It‚Äôs the quality that makes little feel like much, transforms ordinary efforts into lasting impact, and brings contentment that no salary can buy.\nWhen we have barakah in our work, our efforts multiply in ways we never imagined. Time feels more productive, challenges become opportunities for growth, and our contributions ripple outward to benefit our communities in meaningful ways.","what-this-blog-is-about#What This Blog Is About":"This blog is my attempt to document the journey of seeking barakah while building a career in tech. I‚Äôll write about:\nTechnical lessons from my work at Axiom‚Äîthe challenges of full-stack development, API integrations, database design, and real-world problem-solving Career reflections on navigating the tech industry with intentionality and values Community building and how technology can serve as a tool for positive impact Personal growth as I learn to balance ambition with contentment, progress with principle I won‚Äôt pretend to have all the answers. I‚Äôm still early in my journey, still learning, still making mistakes. But I‚Äôm committed to pursuing a path that prioritizes meaning over money, purpose over prestige, and barakah over the hollow metrics of success that our industry celebrates."},"title":"about"},"/barakah-tech-journey/blog/ibm-techxchange-orlando/":{"data":{"1-simple-reflex-agent#1. Simple Reflex Agent":"Operates on if-then rules No memory or state Direct input ‚Üí output mapping","2-model-based-reflex-agent#2. Model-Based Reflex Agent":"Maintains internal state for memory Still uses if-then logic Can track context","3-goal-based-agent#3. Goal-Based Agent":"Provides multiple solutions to achieve a goal Evaluates different paths More flexible than reflex agents","4-utility-based-agent#4. Utility-Based Agent":"Can select the best solution among alternatives Optimizes based on utility functions More sophisticated decision-making","5-learning-agent#5. Learning Agent":"Think ‚Üí Act ‚Üí Observe cycle Reviews past actions stored in memory Continuously improves performance Most advanced agent type Best Practice: Try to make the simplest agent that solves your problem. Don‚Äôt over-engineer.","additional-resources--best-practices#Additional Resources \u0026amp; Best Practices":"","agent-communication-protocols#Agent Communication Protocols":"Modern agents need standardized ways to communicate:\nMCP: Model Context Protocol A2A: Agent-to-Agent communication ANP: Agent Networking Protocol AG UI: Agent User Interface protocols","agent-development-frameworks#Agent Development Frameworks":"Popular templates and libraries for building agents:\nLangChain: Comprehensive chain-based framework LangGraph: Graph-based agent workflows (used in our code examples) CrewAI: Multi-agent collaboration BeeAI: Behavior-driven agents AutoGen: Multi-agent conversations LlamaIndex: Data-focused agent framework","agentic-rag-advanced#Agentic RAG (Advanced):":"User prompt ‚Üí Aggregation Agent Aggregation agent creates a plan Works with 3 specialized agents: Internet search agent API agent Database agent Aggregation agent maintains memory Synthesizes results with LLM for final output Advantages of Agentic RAG:\nMore sophisticated data retrieval Parallel processing capabilities Better context management Improved result quality","agentic-reasoning-strategies#Agentic Reasoning Strategies":"","ai-agent-development-lifecycle#AI Agent Development Lifecycle":"","ai-security#AI Security":"Security in AI: How to make AI systems resistant to hacking\nAs AI systems become more prevalent, securing them against adversarial attacks, prompt injection, and data poisoning becomes critical. This includes implementing proper authentication, input validation, and monitoring systems.","anatomy-of-an-agent#Anatomy of an Agent":"The three core functions: Think ‚Üí Act ‚Üí Observe\nKey Components:\nPerception: Understanding inputs and environment Memory: Storing past interactions and learnings Tool Calling: Accessing datasets, APIs, and external resources Planning: Using prompts to direct behavior and strategy Communication: Interacting with users or other agents Reasoning: Making decisions based on perception and memory","assistant-vs-agent#Assistant vs Agent":"Assistant Agent Handles specific tasks Achieves goals Answers user prompts Proactive problem-solving Reactive Proactive","career-development--technology-adaptation#Career Development \u0026amp; Technology Adaptation":"Always learn new technology and stay ahead. Be flexible to change paths.\nThe rapidly evolving AI landscape demands continuous learning and adaptability. Success in this field requires staying current with emerging frameworks, tools, and methodologies.","career-opportunities#Career Opportunities":"‚ÄúJobs to integrate AI and agents to existing code‚Äù\nThere‚Äôs massive demand for developers who can:\nIntegrate agents into legacy systems Build custom agent solutions Optimize agent performance Ensure security and reliability","conclusion#Conclusion":"This documentation covers:\n‚úÖ Key learnings from IBM TechXchange 2025 ‚úÖ AI agent concepts and architecture ‚úÖ Multiple implementation approaches (LangGraph, Watsonx, Langflow) ‚úÖ Complete, corrected code with detailed comments ‚úÖ Best practices and deployment strategies Next Steps:\nSet up your development environment Choose a framework (start with LangGraph or Langflow) Build a simple agent with one tool Iterate and add complexity Deploy and monitor in production Build agents for Axiom - apply these learnings to real projects! Remember: Start simple, then scale. Build the minimum viable agent that solves your problem, then enhance it based on real-world usage.\nDocument created from IBM TechXchange Orlando 2025 learnings","configuration-breakdown#Configuration Breakdown":"spec_version: Version of the configuration schema\nkind:\nnative: Standard agent that runs in Orchestrate custom: Custom implementation with specific requirements llm: The language model powering the agent\nFormat: provider/model-name Using Meta‚Äôs Llama 3 405B Instruct model One of the most capable open-source models style: Reasoning strategy\nreact: Best for tasks requiring tool use and iterative reasoning Agent will think, act (use tools), and observe results","core-definition#Core Definition":"Agent = LLM + Tools\nAn AI agent is fundamentally code that combines a large language model with specific tools to process inputs and generate desired outputs in a structured manner.","corrected-code-with-comments#Corrected Code with Comments":"from typing import Annotated from langgraph.graph import START, END, StateGraph from langgraph.graph.message import add_messages from langchain_ibm import ChatWatsonx # Fixed: was ChatWatson from dotenv import load_dotenv import os from colorama import Fore # Fixed: was colorma from langgraph.checkpoint.memory import MemorySaver # Fixed: was InMemorySaver from langgraph.prebuilt import ToolNode # Fixed: was prebuild from langgraph.prebuilt import tools_condition # Added: missing import # Load environment variables from .env file load_dotenv() # Initialize the Watson LLM # You need to set MODEL_ID and PROJECT_ID in your .env file llm = ChatWatsonx( model_id=os.getenv('MODEL_ID', 'ibm/granite-13b-chat-v2'), # Default model project_id=os.getenv('PROJECT_ID'), # Your IBM Cloud project ID params={'max_tokens': 5000} ) # Define your tools - these are functions the agent can call # You need to import or define the 'trending' tool # Example tool definition: from langchain_core.tools import tool @tool def trending(query: str) -\u003e str: \"\"\"Get trending information about a topic.\"\"\" # Your implementation here return f\"Trending info for: {query}\" # Bind tools to the LLM so it knows what functions it can call tools = [trending] llm_with_tools = llm.bind_tools(tools) # Create the ToolNode - this executes the tools when called tools_node = ToolNode(tools) # Define the State class - this holds the conversation history class State(dict): \"\"\" State maintains the conversation context. messages: list of all messages in the conversation add_messages: LangGraph function that properly merges new messages \"\"\" messages: Annotated[list, add_messages] def chatbot(state: State): \"\"\" Main chatbot node - processes messages with the LLM. Args: state: Current conversation state Returns: Dictionary with new messages from the LLM \"\"\" print(f\"Current state: {state}\") # Invoke the LLM with the conversation history return {'messages': [llm_with_tools.invoke(state['messages'])]} def router(state: State): \"\"\" Router function - decides whether to call tools or end. Args: state: Current conversation state Returns: 'tools' if the LLM wants to call a tool, END otherwise \"\"\" last_message = state['messages'][-1] # Check if the last message contains tool calls if hasattr(last_message, 'tool_calls') and last_message.tool_calls: return 'tools' else: return END # Build the state graph - this defines the agent's workflow graphbuilder = StateGraph(State) # Add nodes to the graph graphbuilder.add_node('chatbot', chatbot) # LLM processing node graphbuilder.add_node('tools', tools_node) # Tool execution node # Define edges - how the agent flows between nodes graphbuilder.add_edge(START, 'chatbot') # Start with the chatbot graphbuilder.add_edge('tools', 'chatbot') # After tools, go back to chatbot # Add conditional edge - decides whether to use tools or end graphbuilder.add_conditional_edges( 'chatbot', # From the chatbot node router, # Use the router function to decide { 'tools': 'tools', # If router returns 'tools', go to tools node END: END # If router returns END, finish } ) # Initialize memory for conversation history memory = MemorySaver() # Compile the graph with memory checkpoint graph = graphbuilder.compile(checkpointer=memory) # Main execution loop if __name__ == '__main__': print(\"Agent is ready! Type your prompts below.\") # Create a thread ID for conversation continuity thread_id = \"conversation-1\" while True: # Get user input prompt = input(Fore.LIGHTMAGENTA_EX + 'Pass your prompt here: ' + Fore.RESET) # Exit condition if prompt.lower() in ['exit', 'quit', 'bye']: print(\"Goodbye!\") break # Invoke the agent with the user's message # The thread_id maintains conversation memory response = graph.invoke( {'messages': [{'role': 'user', 'content': prompt}]}, config={\"configurable\": {\"thread_id\": thread_id}} ) # Print the agent's response print(Fore.LIGHTCYAN_EX + response['messages'][-1].content + Fore.RESET)","corrected-code-with-comments-1#Corrected Code with Comments":"from ibm_watsonx_orchestrate.agent_builder.tools import tool, ToolPermission import yfinance as yf @tool( name='stock_prices_florida', # Unique identifier for the tool description='This tool returns a stock\\'s last closing price given a stock ticker symbol', # Fixed typo: trock ‚Üí stock permission=ToolPermission.ADMIN # Requires admin permission to execute ) def stock_price(stock_ticker: str) -\u003e str: \"\"\" Retrieves the last closing price for a given stock. Args: stock_ticker: Stock symbol (e.g., 'AAPL', 'GOOGL', 'MSFT') Returns: String representation of the last closing price Example: stock_price('AAPL') ‚Üí '150.25' \"\"\" try: # Create a Ticker object for the given stock ticker = yf.Ticker(stock_ticker) # Get price history for the last month history = ticker.history(period='1mo') # Return the most recent closing price if not history.empty: return str(history['Close'].iloc[-1]) else: return f\"No data available for ticker: {stock_ticker}\" except Exception as e: return f\"Error retrieving price for {stock_ticker}: {str(e)}\" # IBM Watsonx Orchestrate CLI Commands: # 1. Import agent configuration: # uv agents import -f agent.yaml # # 2. Run the agent: # uv run # # 3. Additional tool commands: # uv tool list # List all available tools","corrected-code-with-comments-2#Corrected Code with Comments":"from ibm_watsonx_orchestrate.agent_builder.tools import tool, ToolPermission import yfinance as yf @tool( name='income_statement_florida', description='This tool returns a company\\'s income statement financial data', permission=ToolPermission.ADMIN ) def income_statement(stock_ticker: str) -\u003e str: \"\"\" Retrieves the income statement for a given company. Args: stock_ticker: Stock symbol (e.g., 'AAPL', 'GOOGL', 'MSFT') Returns: Formatted string containing income statement data Example: income_statement('AAPL') ‚Üí Returns revenue, expenses, net income, etc. \"\"\" try: # Create a Ticker object ticker = yf.Ticker(stock_ticker) # Get the income statement income_stmt = ticker.income_stmt # Check if data exists if income_stmt is not None and not income_stmt.empty: # Convert to string format for the agent to read # Get the most recent period (first column) latest_data = income_stmt.iloc[:, 0] # Format key financial metrics result = f\"Income Statement for {stock_ticker}:\\n\" # Extract common metrics if available metrics = [ 'Total Revenue', 'Cost Of Revenue', 'Gross Profit', 'Operating Income', 'Net Income' ] for metric in metrics: if metric in latest_data.index: value = latest_data[metric] result += f\"{metric}: ${value:,.0f}\\n\" return result else: return f\"No income statement data available for ticker: {stock_ticker}\" except Exception as e: return f\"Error retrieving income statement for {stock_ticker}: {str(e)}\" # Additional Notes: # - IBM Watsonx Orchestrate allows you to host a dashboard on localhost # - Agents use libraries and LLMs to produce structured output # - You can combine multiple tools to create comprehensive financial analysis agents # Workflow: # 1. Define tools (like this one) # 2. Configure agent in agent.yaml # 3. Import: uv agents import -f agent.yaml # 4. Run: uv run # 5. Test in the Orchestrate dashboard # Resource: lmsys-leaderboard on Hugging Face shows ranked LLM performance","corrected-yaml-with-comments#Corrected YAML with Comments":"# IBM Watson Agent Configuration # This file defines the agent's specifications for Watsonx Orchestrate spec_version: v1 # Configuration specification version kind: native # Agent type: native (runs directly) vs. custom name: TechExchangeFinanceAgent # Unique agent identifier description: This agent is great at all things stock research. # Agent purpose # LLM Configuration # Fixed typo: llma ‚Üí llama llm: watsonx/meta-llama/llama-3-405b-instruct # Model to use # Agent Reasoning Style style: react # ReAct pattern (Reasoning + Acting) # Options: react, rewoo, chain-of-thought, etc. # Additional Configuration Options (optional): # tools: # List of tools this agent can use # - stock_prices_florida # - income_statement_florida # # temperature: 0.7 # Controls randomness (0-1) # max_tokens: 2000 # Maximum response length # # system_prompt: | # Custom instructions for the agent # You are a financial research assistant specializing in stock analysis. # Provide accurate, data-driven insights based on the available tools.","development-tools#Development Tools":"Excalidraw for Design\nUse Excalidraw (https://excalidraw.com) for agent architecture diagrams Visualize agent workflows before coding Share designs with team members Great for planning multi-agent systems","environment-setup#Environment Setup":"Create a .env file for sensitive data:\n# IBM Watson Configuration MODEL_ID=ibm/granite-13b-chat-v2 PROJECT_ID=your-project-id-here # API Keys WATSONX_API_KEY=your-api-key IBM_CLOUD_API_KEY=your-cloud-key # Other configurations MAX_TOKENS=5000 TEMPERATURE=0.7","evaluator-pattern-optimizer#Evaluator Pattern (Optimizer)":"Two agents working together iteratively Back-and-forth refinement Continuous improvement cycle","file-1-agentpy---langgraph-implementation#File 1: \u003ccode\u003eagent.py\u003c/code\u003e - LangGraph Implementation":"","file-2-pricepy---stock-price-tool#File 2: \u003ccode\u003eprice.py\u003c/code\u003e - Stock Price Tool":"","file-3-incomepy---income-statement-tool#File 3: \u003ccode\u003eincome.py\u003c/code\u003e - Income Statement Tool":"","file-4-agentyaml---agent-configuration#File 4: \u003ccode\u003eagent.yaml\u003c/code\u003e - Agent Configuration":"","file-5-langflowpy---no-code-agent-building#File 5: \u003ccode\u003elangflow.py\u003c/code\u003e - No-Code Agent Building":"","function-breakdown#Function Breakdown":"Tool Decorator\n@tool registers this function with IBM Watsonx Orchestrate name: How the agent refers to this tool description: Helps the LLM decide when to use this tool permission: Controls who can execute this tool Implementation\nUses yfinance library to fetch real-time stock data Retrieves 1 month of historical data Returns the most recent closing price Includes error handling for invalid tickers","ibm-techxchange-orlando-2025#IBM TechXchange Orlando 2025":"IBM TechXchange Orlando 2025","ibm-watsonx-orchestrate#IBM Watsonx Orchestrate":"A comprehensive platform for building, deploying, and managing AI agents.\nFeatures:\nAgent marketplace for pre-built solutions AgentOps: Tools to manage and monitor agent performance Integration with existing workflows","key-concepts-explained#Key Concepts Explained":"1. State Management\nThe State class stores the conversation history add_messages annotation ensures messages are properly merged Memory persists across turns using MemorySaver 2. Tool Binding\nllm.bind_tools(tools) teaches the LLM what functions it can call The LLM decides when to call tools based on the conversation ToolNode executes the actual tool functions 3. Graph Structure\nSTART ‚Üí chatbot ‚Üí (decision) ‚Üí tools ‚Üí chatbot ‚Üí END Chatbot processes the input Router decides if tools are needed Tools execute if needed Returns to chatbot for final response 4. Memory\nMemorySaver stores conversation history thread_id maintains conversation context Agent can reference previous messages","key-improvements#Key Improvements":"Original Issue: Function was named stock_price but tool name was income_statement_florida\nCorrections Made:\nRenamed function to income_statement for consistency Implemented actual income statement retrieval Added formatting for key financial metrics Included error handling Added comprehensive documentation","key-learnings--ai-agent-development-guide#Key Learnings \u0026amp; AI Agent Development Guide":"","langflow-workflow#Langflow Workflow":"# Method 2: Build an agent without code using Langflow (DataStax) \"\"\" Langflow is a visual interface for building LLM applications and agents. No coding required - use drag-and-drop components. STEP-BY-STEP GUIDE: 1. Add Chat Input Component - This is where users will type their messages - Configure input parameters if needed 2. Add Agent Component - The core processing unit - Configure agent behavior and settings 3. Add LLM/Model to the Agent - Select your model provider (OpenAI, Anthropic, IBM Watson, etc.) - Enter API key in the component settings - Configure model parameters: * Temperature: Controls randomness * Max tokens: Response length * System prompt: Agent instructions 4. Add Tools to the Agent - Example: arXiv tool * Searches academic papers * Retrieves research information * Returns relevant findings - Other available tools: * Web Search (Google, Bing, DuckDuckGo) * Wikipedia * Calculator * Python REPL * Custom API tools 5. Add Chat Output Component - Displays agent responses to users - Configure output formatting 6. Connect the Components - Draw connections between components: Chat Input ‚Üí Agent ‚Üí Chat Output Model ‚Üí Agent Tools ‚Üí Agent 7. Test in Playground - Click the \"Playground\" button - Chat with your agent in real-time - Iterate and refine based on results 8. View and Customize Code - Click \"View Code\" to see the generated Python code - Export code for custom deployment - Modify and extend functionality - Version control your agent ADVANTAGES OF LANGFLOW: - No coding required to get started - Visual representation of agent architecture - Quick prototyping and iteration - Easy tool integration - Built-in testing environment - Can export to code when needed DEPLOYMENT OPTIONS: - DataStax Langflow Cloud (hosted) - Self-hosted (Docker, local server) - Export to custom Python application USE CASES: - Research assistants (with arXiv, web search) - Customer support bots - Data analysis agents - Content creation assistants - Multi-tool orchestration \"\"\" # Example: What the generated code might look like from langflow import ChatInput, ChatOutput, Agent from langflow.components import OpenAI, ArxivTool # This is automatically generated by Langflow def build_agent(): # Input component chat_input = ChatInput() # LLM component llm = OpenAI( model=\"gpt-4\", api_key=\"your-api-key\", temperature=0.7 ) # Tool component arxiv = ArxivTool() # Agent component agent = Agent( llm=llm, tools=[arxiv], system_message=\"You are a research assistant.\" ) # Output component chat_output = ChatOutput() # Connect components agent.connect(chat_input, chat_output) return agent","monitoring--logging#Monitoring \u0026amp; Logging":"import logging # Configure logging logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__) def chatbot(state: State): logger.info(f\"Processing message: {state['messages'][-1]}\") # ... rest of function","opportunities--action-items#Opportunities \u0026amp; Action Items":"","orchestrator-pattern#Orchestrator Pattern":"Central agent coordinates multiple specialized agents Synthesizer agent produces final output Good for complex, multi-step workflows","overview-of-code-files#Overview of Code Files":"The provided codebase demonstrates building AI agents using multiple approaches:\nLangGraph (Python framework) - agent.py IBM Watsonx Orchestrate - agent.yaml, price.py, income.py Langflow (no-code) - langflow.py","page-1-core-insights-and-industry-trends#Page 1: Core Insights and Industry Trends":"","page-2-code-implementation---building-ai-agents-with-langgraph#Page 2: Code Implementation - Building AI Agents with LangGraph":"GitHub Repo to learn more on building ai agents\nRepo for building an AI agent using IBM orchestrate","page-3-additional-implementation-details#Page 3: Additional Implementation Details":"","parallelization-of-agents#Parallelization of Agents":"Multiple agents working simultaneously on different aspects of a problem.","performance-optimization#Performance Optimization":"Caching: Store repeated API calls Token Management: Monitor and limit token usage Parallel Processing: Use async for multiple tool calls Error Handling: Graceful degradation when tools fail","personal-projects#Personal Projects":"Build some agents for Axiom!\nApply these learnings to real-world projects. Start simple and iterate.","purpose#Purpose":"This file implements a chatbot agent using LangGraph with tool-calling capabilities and memory. It demonstrates the core concepts of agent architecture: state management, tool integration, and conversational flow.","purpose-1#Purpose":"Defines a tool for retrieving stock prices using Yahoo Finance. This tool can be imported into agents built with IBM Watsonx Orchestrate.","purpose-2#Purpose":"Similar to price.py, but intended to retrieve income statement data. Note: Current implementation actually returns stock price (needs correction).","purpose-3#Purpose":"Configuration file for IBM Watsonx Orchestrate agents. Defines the agent‚Äôs properties, model, and behavior style.","purpose-4#Purpose":"Documentation for building agents using Langflow, a visual drag-and-drop interface powered by DataStax.","react-reasoning--acting#ReAct (Reasoning + Acting)":"If answer not found, keeps prompting until it does Resource-intensive approach Requires exit conditions to prevent infinite loops Continuous observation and adjustment","retrieval-augmented-generation-rag#Retrieval Augmented Generation (RAG)":"","rewoo-reasoning-without-observation#ReWOO (Reasoning Without Observation)":"Doesn‚Äôt loop back More efficient resource usage Single-pass reasoning Better for straightforward tasks","stages#Stages:":"Planning: Define objectives and scope Design: Architecture and interaction patterns Framework, Model \u0026 Tool Selection: Choose appropriate tech stack Training: Fine-tune and optimize Evaluation: Test performance and accuracy Deployment \u0026 Monitoring: Production rollout with ongoing observation","testing-strategy#Testing Strategy":"Unit Testing: Test individual tools def test_stock_price(): result = stock_price('AAPL') assert result is not None assert isinstance(result, str) Integration Testing: Test agent workflows def test_agent_flow(): response = graph.invoke({ 'messages': [{'role': 'user', 'content': 'What is AAPL stock price?'}] }) assert 'messages' in response End-to-End Testing: Test complete user scenarios","the-big-opportunity-infrastructure-integration#The Big Opportunity: Infrastructure Integration":"Generative AI Integration into Existing Infrastructure\nThe partnership between Anthropic and IBM focuses on this exact challenge: helping enterprises integrate generative AI capabilities into their existing technology stacks without complete overhauls. This represents one of the largest opportunities in the AI space today.","tools--resources#Tools \u0026amp; Resources":"Bob in VS Code: A productivity tool worth exploring IBM Products: https://www.ibm.com/products","traditional-rag-flow#Traditional RAG Flow:":"User prompt ‚Üí Server Server searches for top relevant results Server asks model to process selected data Model generates response with retrieved context","types-of-ai-agents#Types of AI Agents":"","understanding-ai-agents#Understanding AI Agents":"","when-to-use-langflow#When to Use Langflow":"Pros:\nRapid prototyping No coding knowledge required Visual debugging Easy tool integration Great for non-technical stakeholders Cons:\nLess control than code-based approaches May have limitations for complex logic Dependency on Langflow platform Best For:\nQuick proof-of-concepts Business users building agents Testing different model/tool combinations Educational purposes"},"title":"ibm-techxchange-orlando"},"/barakah-tech-journey/docs/calendly/":{"data":{"additional-resources#Additional Resources":"Calendly API Documentation Developer Console API Reference Community Forum Happy integrating! üöÄ","architecture-recommendations#Architecture Recommendations":"","backend-components#Backend Components":"1. Webhook Controller:\nValidate signatures Deserialize payloads Route to appropriate handlers 2. Event Manager:\nProcess event lifecycle (create, reschedule, cancel) Manage recipients and relationships Handle URI-based event tracking 3. Data Layer:\nStore calendar events Track event recipients (hosts, invitees, guests) Maintain integration settings","common-gotchas#Common Gotchas":"Rescheduling creates new events: Use URI-based tracking to link rescheduled events Signature verification timing: Always validate before processing Timezone handling: Store times in UTC, display in user‚Äôs timezone Multiple guests: Process both event_memberships and event_guests arrays","common-implementation-patterns#Common Implementation Patterns":"1. Contact Management: Create or update contacts in your CRM from invitee data\n2. Calendar Synchronization: Store events in your database with:\nURI-based unique identification (handles rescheduling) IsActive flags for soft deletion of canceled events Proper host/invitee relationship tracking 3. Activity Logging: Generate activity records for all event participants\n4. User Interface Integration: Display events in:\nMain calendar views Contact activity feeds Dashboard widgets","conclusion#Conclusion":"Implementing Calendly integration provides seamless calendar synchronization and eliminates manual data entry. By following OAuth best practices, properly verifying webhooks, and handling all event types, you can build a robust integration that enhances your application‚Äôs scheduling capabilities.","create-a-developer-account#Create a Developer Account":"First, you‚Äôll need to create a Calendly developer account and register your application:\nSign up for a developer account at Calendly Developer Console\nCreate a new OAuth application and configure:\nApplication Name: Your app‚Äôs name Application Type: Web or Native Environment: Start with Sandbox for development, then create a Production app when ready Redirect URI: Sandbox: HTTP with localhost is allowed (e.g., http://localhost:1234) Production: Must use HTTPS (e.g., https://yourdomain.com/auth/calendly) Save your credentials - you‚Äôll receive:\nClient ID Client Secret Webhook Signing Key (critical for security - you can only view this once!) Documentation: Create a Developer Account","database-schema#Database Schema":"Consider these tables:\nCalendarEvent:\nURI (unique identifier) Title, start/end times, location Integration source IsActive flag for soft deletion CalendarEventRecipient:\nEvent relationship Contact information Role (host/invitee/guest) IntegrationSite:\nUser/organization association OAuth credentials Webhook signing keys (encrypted)","development-tips#Development Tips":"Start with Calendly‚Äôs Sandbox environment for testing Use tools like ngrok to expose localhost for webhook testing Log all webhook payloads during development Test all event types: create, reschedule, cancel, no-show","extracting-useful-information#Extracting Useful Information":"From the webhook payload, you can extract:\nEvent Details:\nMeeting title (payload.scheduled_event.name) Start/end times (payload.scheduled_event.start_time, end_time) Location (payload.scheduled_event.location) Meeting notes (payload.scheduled_event.meeting_notes_plain) Invitee Information:\nName and email (payload.name, payload.email) First/last name (if configured separately) Timezone (payload.timezone) Custom question responses (payload.questions_and_answers) Host/Attendee Details:\nEvent memberships (payload.scheduled_event.event_memberships) Additional guests (payload.scheduled_event.event_guests)","how-to-implement-calendly-integration-into-your-web-application#How to Implement Calendly Integration into Your Web Application":"How to Implement Calendly Integration into Your Web ApplicationIntegrating Calendly into your web application can streamline meeting scheduling and automatically sync calendar events with your CRM or internal systems. This guide walks through the complete implementation process, from OAuth authentication to webhook processing.","key-takeaways#Key Takeaways":"Register your app in Calendly Developer Console Implement proper OAuth flow with secure token storage Create webhook subscriptions for real-time event notifications Always verify webhook signatures to ensure authenticity Handle all event lifecycle stages (create, reschedule, cancel) Store events with URI-based unique identification","overview#Overview":"A complete Calendly integration involves three main phases:\nOAuth Authentication - Authorize your application to access Calendly data Webhook Subscription - Set up real-time notifications for calendar events Webhook Processing - Receive and process event data in your application","phase-1-setting-up-your-calendly-application#Phase 1: Setting Up Your Calendly Application":"","phase-2-implementing-oauth-authentication#Phase 2: Implementing OAuth Authentication":"","phase-3-creating-a-webhook-subscription#Phase 3: Creating a Webhook Subscription":"","phase-4-processing-webhook-notifications#Phase 4: Processing Webhook Notifications":"","phase-5-processing-event-data#Phase 5: Processing Event Data":"","security-best-practices#Security Best Practices":"Always verify webhook signatures - Never trust unverified webhooks Implement replay attack prevention - Use timestamp validation Encrypt sensitive data - Store API keys and signing keys encrypted Use HTTPS - Required for production webhook endpoints Rate limiting - Implement rate limits on your webhook endpoint Error handling - Log errors but avoid exposing sensitive information","step-1-get-authorization-code#Step 1: Get Authorization Code":"Redirect users to Calendly‚Äôs authorization page to grant access to your application:\nhttps://auth.calendly.com/oauth/authorize?client_id=YOUR_CLIENT_ID\u0026response_type=code\u0026redirect_uri=https://yourdomain.com/auth/calendly Parameters:\nclient_id - Your application‚Äôs Client ID response_type - Always ‚Äúcode‚Äù redirect_uri - Must match the URI registered in your app settings When users grant access, Calendly redirects to your specified URI with the authorization code:\nhttps://yourdomain.com/auth/calendly?code=f04281d639d8248435378b0365de7bd1f53bf452eda187d5f1e07ae7f04546d6 Documentation: Get Authorization Code","step-2-exchange-code-for-access-token#Step 2: Exchange Code for Access Token":"Make a POST request to exchange the authorization code for an access token:\nEndpoint: POST https://auth.calendly.com/oauth/token\nRequest Body:\n{ \"grant_type\": \"authorization_code\", \"code\": \"AUTHORIZATION_CODE_FROM_STEP_1\", \"client_id\": \"YOUR_CLIENT_ID\", \"client_secret\": \"YOUR_CLIENT_SECRET\", \"redirect_uri\": \"https://yourdomain.com/auth/calendly\" } Response:\n{ \"access_token\": \"eyJraWQiOiIxY2UxZTEzNjE...\", \"refresh_token\": \"eyJraWQiOiIxY2UxZTEzNjE...\", \"token_type\": \"Bearer\", \"expires_in\": 7200, \"scope\": \"default\" } Store the access token securely - you‚Äôll need it for all subsequent API calls.","subscribe-to-calendar-events#Subscribe to Calendar Events":"Create a webhook subscription to receive real-time notifications when meetings are scheduled, canceled, or modified.\nEndpoint: POST https://api.calendly.com/webhook_subscriptions\nHeaders:\nAuthorization: Bearer YOUR_ACCESS_TOKEN\rContent-Type: application/json Request Body:\n{ \"url\": \"https://yourdomain.com/api/webhook/calendly\", \"events\": [ \"invitee.created\", \"invitee.canceled\", \"invitee_no_show.created\", \"invitee_no_show.deleted\" ], \"organization\": \"https://api.calendly.com/organizations/AAAAAAAAAAAAAAAA\", \"user\": \"https://api.calendly.com/users/BBBBBBBBBBBBBBBB\", \"scope\": \"user\", \"signing_key\": \"YOUR_WEBHOOK_SIGNING_KEY\" } Key Parameters:\nurl - Your server endpoint that will receive webhook notifications events - Array of events to subscribe to: invitee.created - New meeting bookings invitee.canceled - Meeting cancellations invitee_no_show.created - No-show events routing_form_submission.created - Routing form submissions (organization scope only) scope - Either ‚Äúuser‚Äù (individual events) or ‚Äúorganization‚Äù (all team events) signing_key - Your webhook signing key for payload verification Documentation:\nCreate Webhook Subscription Webhook Subscriptions Guide","testing-your-integration#Testing Your Integration":"","verifying-webhook-signatures#Verifying Webhook Signatures":"Critical: Always verify webhook signatures to ensure requests are authentic and haven‚Äôt been tampered with.\nCalendly includes a Calendly-Webhook-Signature header with each webhook:\nCalendly-Webhook-Signature: t=1492774577,v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd Verification Steps:\nExtract the timestamp (t) and signature (v1) from the header Create the signed payload: timestamp + \".\" + JSON.stringify(requestBody) Compute HMAC-SHA256 hash using your signing key Compare the computed signature with the received signature Verify the timestamp is within your tolerance window (e.g., 3 minutes) Example Implementation (Node.js):\nconst crypto = require('crypto'); const webhookSigningKey = process.env.WEBHOOK_SIGNING_KEY; const calendlySignature = req.get('Calendly-Webhook-Signature'); // Parse signature header const { t, signature } = calendlySignature.split(',').reduce((acc, current) =\u003e { const [key, value] = current.split('='); if (key === 't') acc.t = value; if (key === 'v1') acc.signature = value; return acc; }, { t: '', signature: '' }); // Create signed payload const data = t + '.' + JSON.stringify(req.body); // Compute expected signature const expectedSignature = crypto .createHmac('sha256', webhookSigningKey) .update(data, 'utf8') .digest('hex'); // Verify signature matches if (expectedSignature !== signature) { throw new Error('Invalid Signature'); } // Prevent replay attacks - reject old timestamps const threeMinutes = 180000; const timestampMilliseconds = Number(t) * 1000; if (timestampMilliseconds \u003c Date.now() - threeMinutes) { throw new Error('Signature timestamp outside tolerance zone'); } Documentation: Webhook Signatures","webhook-payload-structure#Webhook Payload Structure":"When an event occurs, Calendly sends a POST request to your webhook URL with this structure:\n{ \"created_at\": \"2020-11-23T17:51:19.000000Z\", \"created_by\": \"https://api.calendly.com/users/AAAAAAAAAAAAAAAA\", \"event\": \"invitee.created\", \"payload\": { \"uri\": \"https://api.calendly.com/scheduled_events/AAAAAAAAAAAAAAAA/invitees/AAAAAAAAAAAAAAAA\", \"email\": \"test@example.com\", \"name\": \"John Doe\", \"status\": \"active\", \"timezone\": \"America/New_York\", \"scheduled_event\": { \"uri\": \"https://api.calendly.com/scheduled_events/GBGBDCAADAEDCRZ2\", \"name\": \"15 Minute Meeting\", \"status\": \"active\", \"start_time\": \"2019-08-24T14:15:22.123456Z\", \"end_time\": \"2019-08-24T14:15:22.123456Z\", \"location\": { \"type\": \"physical\", \"location\": \"string\" }, \"event_memberships\": [ { \"user\": \"https://api.calendly.com/users/GBGBDCAADAEDCRZ2\", \"user_email\": \"user@example.com\", \"user_name\": \"John Smith\" } ], \"event_guests\": [] } } } Documentation: Webhook Payload"},"title":"calendly"}}